@page "/query/{*Path}"
@using Microsoft.Data.SqlClient
@inject LocationQueryRunner Runner
@inject NavigationManager NavigationManager
@inject IOptions<AppSettings> Options
@inject IJSRuntime Js
@inject CircuitState Cs
@implements IDisposable

@{
    renderCount++;

    log.Debug($"Render {instanceId} #{renderCount}, query state: {lastQueryTask?.Status}");
}

<PageTitle>@vm?.Result.RootName</PageTitle>

<DefaultLayout IsLoading="@(vm == null)">
    <NavItems>
        <BreadcrumbItem><a class="text-muted" href="/">Databases</a></BreadcrumbItem>
        <BreadcrumbItem><a class="text-muted" href="@vm.Result.RootUrl.If(vm.Result.QueryType != QueryControllerQueryType.Root)">@vm.Result.RootName</a></BreadcrumbItem>
        <CascadingValue Value="QueryContext">
            @if (vm.Result.PrincipalEntities != null)
            {
                var entity = vm.Result.PrincipalEntities.List.Single("Unexpectedly not having a unique principal");

                <BreadcrumbItem>
                    <span class="entity-context text-muted">
                        <EntityHeaderView Table="@vm.Result.PrincipalRelation.OtherEnd.Table" Entity="@entity" />
                    </span>
                </BreadcrumbItem>
                <BreadcrumbItem>
                    <span class="text-muted"><EntityRelationNameView RelationEnd="@vm.Result.PrincipalRelation" NoColumnInformation="@true" /></span>
                </BreadcrumbItem>
            }
            else if (vm.LastResult.PrimaryEntities?.List.FirstOrDefault() is Entity primaryEntity)
            {
                var entity = primaryEntity;

                switch (vm.Result.QueryType)
                {
                    case QueryControllerQueryType.Table:
                        <span class="entity-context text-muted"><EntityRelationNameView RelationEnd="@vm.Result.PrimaryEntities.RelationEnd" NoColumnInformation="@true" /></span>
                        break;
                    case QueryControllerQueryType.Row:

                        <BreadcrumbItem>
                            <a class="entity-context text-muted" href="@QueryContext.RenderTableUrl(vm.Result.Table)"><EntityRelationNameView RelationEnd="@vm.Result.PrimaryEntities.RelationEnd" NoColumnInformation="@true" /></a>
                        </BreadcrumbItem>

                        <BreadcrumbItem>
                            <span class="text-muted entity-context">
                                <EntityHeaderView Table="@vm.Result.PrimaryEntities.RelationEnd.Table" Entity="@entity" ShowLink="@false" />
                            </span>
                        </BreadcrumbItem>
                        break;
                    case QueryControllerQueryType.Column:
                        <BreadcrumbItem>
                            <a class="entity-context text-muted" href="@QueryContext.RenderTableUrl(vm.Result.Table)"><EntityRelationNameView RelationEnd="@vm.Result.PrimaryEntities.RelationEnd" NoColumnInformation="@true" /></a>
                        </BreadcrumbItem>

                        <BreadcrumbItem>
                            <a class="text-muted entity-context" href="@QueryContext.RenderEntityUrl(vm.Result.Table, entity)">
                                <EntityHeaderView Table="@vm.Result.PrimaryEntities.RelationEnd.Table" Entity="@entity" ShowLink="@false" />
                            </a>
                        </BreadcrumbItem>

                        <BreadcrumbItem>
                            <span>@vm.LastRequest.Column</span>
                        </BreadcrumbItem>
                        break;
                    case QueryControllerQueryType.TableSlice:
                        @* Should have been handled above by having a principal entity *@
                        <i>some slice</i>
                        break;
                    case QueryControllerQueryType.Root:
                    default:
                        break;
                }
            }
        </CascadingValue>
    </NavItems>

    <ActionItems>
        <div class="btn-group">
            @if (Settings.EnableDevMode)
            {
                <a class="btn btn-outline-dark text-muted"  href="/info/@SourceName">schema</a>
                <button class="btn btn-outline-dark text-muted" @onclick="OpenReportModal">report</button>
            }
            <button class="btn btn-outline-dark text-muted" @onclick="OpenSqlModal"><strong>SQL</strong></button>
        </div>
    </ActionItems>

    <ChildContent>

        <CascadingValue Value="QueryContext">

            <SidebarLayout>
                <RightContent>
                    <div class="common-lead-spacer">&nbsp;</div>

                    @if(Settings.EnableDevMode)
                    {
                        if (vm.LastResult?.Ledger != null)
                        {
                            <div>
                                <span>@queryCount / @renderCount</span>
                            </div>
                            <div class="common-lead-spacer">&nbsp;</div>
                            <div class="">
                                <dl>
                                    @foreach (var entry in vm.LastResult.Ledger.GetEntries())
                                    {
                                        <dt>@entry.name</dt>
                                        <dd>@entry.time</dd>
                                    }
                                </dl>
                            </div>
                        }
                    }
                    else
                    {
                        <h5 class="text-muted font-weight-bold border-bottom mb-4">Guidance</h5>
                        <div class="sidebar-helptext small text-muted">
                            <HelpText QueryType="@vm.LastResult.QueryType" />
                        </div>
                    
                    }
                </RightContent>

                <LeftContent>
                    @if (vm.SearchOptions != null)
                    {
                        <div class="common-lead-spacer">&nbsp;</div>
                        <SearchPanel Vm="vm" SearchValues="SearchValues" />
                    }
                </LeftContent>

                <ChildContent>

                    @switch(vm.LastResult.QueryType)
                    {
                        case QueryControllerQueryType.Table:
                        case QueryControllerQueryType.TableSlice:
                            <div class="search-panel-spacer">&nbsp;</div>
                            break;
                    }

                    <div class="common-lead-spacer">&nbsp;</div>

                    @if (Settings.ShowHelpTexts)
                    {
                        <p class="d-block d-lg-none"><i class="fa fa-exclamation-triangle"></i> Note that there are some explanatory texts on larger screens.</p>
                    }

                    @if (vm.LastResult.Exception is SqlException se)
                    {
                        <div class="alert alert-danger">
                            <div class="mb-2">
                                The database sent an unexpected error, this is likely a bug.
                            </div>

                            <pre class="mb-0">
                                @foreach (Microsoft.Data.SqlClient.SqlError msg in se.Errors)
                                {
                                    <div>@msg.Message</div>
                                }
                            </pre>
                        </div>
                    }
                    else if(vm.LastResult.Exception is Exception e)
                    {
                        <div class="alert alert-danger">
                            <div>
                                An internal exception occurred during this query, this is likely a bug.
                            </div>
                        </div>
                    }

                    @if (vm.DisplayedEntity != null)
                    {
                        <div class="@ClassNames("entity-context", "entity-invalid".If(!vm.LastResult.IsOk))">
                            <EntityContentView Entity="@vm.DisplayedEntity" HideHeaders="@(vm.LastResult.QueryType != QueryControllerQueryType.Root)" />
                        </div>

                        @switch (vm.CanLoadMore())
                        {
                            case CanLoadMoreStatus.Can:
                                if (vm.LastRequest.ListLimit < Settings.LoadMoreLimit)
                                {
                                    <div class="my-4">
                                        <em class="btn">...and more</em> <button class="btn btn-light" @onclick="HandleLoadMoreClick">load <span>@Settings.LoadMoreLimit</span> at once</button>
                                    </div>
                                }
                                else
                                {
                                    <div class="my-4">
                                        <em class="btn">...and more (maximum load size reached)</em>
                                    </div>
                                }
                                break;
                            case CanLoadMoreStatus.Complete:
                            case CanLoadMoreStatus.Unavailable:
                            default:
                                break;
                        }

                        <div class="common-lead-spacer">&nbsp;</div>
                    }

                    <div class="@ClassNames("query-delay-overlay text-light"@*, "querying".If(IsQuerying)*@)">
                        <div class="query-delay-overlay-backdrop" />
                        <h2>Querying!</h2>
                    </div>

                    <Modal OnClose="SqlModalSubscription">
                        <Title>SQL Query</Title>
                        <HeaderExtra>
                            <small>
                                <p class="mt-2 me-4">
                                    Each page's data is requested in only one query. The query is textually long, but
                                    executes efficiently as it relies only on a series of nested table seeks.
                                    This is guaranteed unless you use the scanning search or you hit a bug.
                                </p>
                                <p>
                                    Although this query uses the nonstandard XML query syntax of SQL Server, a similar
                                    query can be created for most other database engines. However, these may look even more
                                    convoluted then.
                                </p>

                            </small>
                        </HeaderExtra>
                        <Body>
                            <pre><CopyableContent>@(vm.LastResult?.Ledger.GetLastEntry<QuerySql>()?.Sql)</CopyableContent></pre>
                        </Body>
                    </Modal>

                    <Modal OnClose="ReportModalSubscription">
                        <Title>Query report</Title>
                        <Body>
                            @foreach (var entry in vm.LastResult.Ledger.GetEntries())
                            {
                                var result = entry.result.GetReportString();

                                <h5>@entry.name<br /><small>@entry.time</small></h5>
                                @if (result is String s)
                                {
                                    <pre>
                                        <CopyableContent>@s</CopyableContent>
                                    </pre>
                                }
                            }
                        </Body>
                    </Modal>

                </ChildContent>
            </SidebarLayout>
        </CascadingValue>
    </ChildContent>
</DefaultLayout>

<RerenderHelper Observable="@SearchValues.Backing" OnChange="@HandleSeekValuesChanged" />

@code {
    static Logger log = LogManager.GetCurrentClassLogger();

    static Int32 staticInstanceId = 0;

    Int32 instanceId = (staticInstanceId++ % 10);

    [Parameter]
    public String Path { get; set; }

    [CascadingParameter]
    public CurrentLocation Location { get; set; }

    Boolean IsQuerying => lastQueryTask?.IsCompleted != true;

    String SourceName { get; set; }

    Int32 listLimit;

    Boolean haveLocationChange = false;

    AppSettings Settings => Options.Value;

    Int32 renderCount, queryCount;

    IMap<String, String> SearchValues => Cs.SearchValuesByLocation[Location.Location];

    Task lastQueryTask;

    Boolean haveQueryPending;
    Boolean jsInitPending;

    LocationQueryVm vm = null;

    QueryContext QueryContext { get; set; }

    void OpenSqlModal() => SqlModalSubscription = () => SqlModalSubscription = null;

    Action SqlModalSubscription { get; set; }

    void OpenReportModal() => ReportModalSubscription = () => ReportModalSubscription = null;

    Action ReportModalSubscription { get; set; }

    async void RunQuery(Boolean synchronously = false)
    {
        if (lastQueryTask?.IsCompleted == false)
        {
            log.Debug("Scheduling query");

            haveQueryPending = true;
        }
        else
        {
            log.Debug($"Starting new query {(synchronously ? "synchronously" : "asynchronously")}");

            lastQueryTask = InnerRunQuery(synchronously);

            if (lastQueryTask.IsCompleted)
            {
                log.Debug($"Query completed synchronously");
            }
            else
            {
                log.Debug($"Query is running asynchronously");
            }

            StateHasChanged();

            await lastQueryTask;

            StateHasChanged();

            if (haveQueryPending)
            {
                log.Debug($"Recursing on scheduled query");

                haveQueryPending = false;

                RunQuery();
            }
        }
    }

    async Task InnerRunQuery(Boolean synchronously = false)
    {
        var query = new Uri(NavigationManager.Uri).Query;

        var queryParams = HttpUtility.ParseQueryString(query);

        var request = new LocationQueryRequest(Path, queryParams, SearchValues.ToNameValueCollection())
        {
            ListLimit = listLimit
        };

        SourceName = request.Source;

        var result = synchronously ? Runner.Query(SourceName, request) : await Task.Run(() => Runner.Query(SourceName, request));

        if (result.Exception != null && result.Exception is not SqlException)
        {
            Js.InvokeVoidAsync("console.log", result.Exception.ToString()).Ignore();
        }

        ++queryCount;

        if (haveLocationChange)
        {
            vm = new LocationQueryVm(request, result);

            QueryContext = new QueryContext(SourceName);

            QueryContext.InDebug = queryParams["debug"] != null;

            haveLocationChange = false;
        }
        else
        {
            vm.Update(request, result);
        }

        jsInitPending = true;
    }

    void HandleSeekValuesChanged()
    {
        log.Debug("Seek values changed");

        RunQuery();
    }

    void HandleLoadMoreClick()
    {
        listLimit = Settings.LoadMoreLimit + 1;

        RunQuery();
    }

    protected override void OnParametersSet()
    {
        log.Debug($"OnParametersSet at {Path}");

        base.OnParametersSet();

        if (vm == null)
        {
            RunQueryAfterLocationChange(true);
        }
    }

    protected override void OnInitialized()
    {
        NavigationManager.LocationChanged += LocationChanged;
    }

    protected override async Task OnAfterRenderAsync(Boolean firstRender)
    {
        log.Debug($"rendered content");

        if (jsInitPending)
        {
            jsInitPending = false;

            log.Debug($"init boostrap content after render");

            await Js.InvokeVoidAsync("initBootstrapContent");
        }
    }

    void LocationChanged(object sender, LocationChangedEventArgs e)
    {
        log.Debug($"LocationChanged at {Path}");

        RunQueryAfterLocationChange(false);
    }

    void RunQueryAfterLocationChange(Boolean synchronously)
    {
        listLimit = Settings.InitialLimit;
        haveLocationChange = true;

        RunQuery(synchronously);
    }

    void IDisposable.Dispose()
    {
        NavigationManager.LocationChanged -= LocationChanged;
    }
}
